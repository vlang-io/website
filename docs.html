@t header



<script  src="/js/jquery.min.js"></script>

<script>
$(document).ready(function() { $("a:contains(Documentation)").css('font-weight', '500') })
</script>

<style>
#social, #sub-form, #main-header, #logo {
display: none;
}

/*
input[type=button] { display:none}
*/

h2 {
	border-top: 1px solid #dfdfdf;
	padding-top: 10px;
}



code {
	font-family: 'Roboto Mono';
	background-color: #f0f0f0;
	padding: 1px 3px 1px 3px;
}

</style>

<script>
$(document).ready(function() {
	$('.run').click(function() {
		var text = $(this).prev('pre').text()
		//if (text.indexOf('fn main') == -1) {
			//text = 'fn main() {\n' + text + '\n}'
		//}
		localStorage.setItem('play', text)
		window.open('/play')
	});
});
</script>


<div class='center'>



<div class='toc'>
<a href='#introduction'>%introduction</a>
<a href='#hello'>Hello World</a>
<a href='#comments'>%comments</a>
<a href='#fns'>%functions</a>
<a href='#vars'>%variables</a>
<a href='#btypes'>%basic_types</a>
<a href='#strings'>%strings</a>
<a href='#arrays'>%arrays</a>
<a href='#maps'>%maps</a>
<a href='#if'>If</a>
<a href='#in'>%in_op</a>
<a href='#for'>%for_loop</a>
<a href='#match'>%match</a>
<a href='#structs'>%structs</a>
<a href='#mod'>%access_mod</a>
<a href='#methods'>%methods</a>
<a href='#recvs'>%pure_fns</a>
<a href='#highfns'>%high_fns</a>
<a href='#refs'>%references</a>
<a href='#consts'>%constants</a>
<a href='#println'>%println</a>
<a href='#modules'>%modules</a>
<a href='#interfaces'>%interfaces</a>
<a href='#enums'>%enums</a>
<a href='#option'>%optionals_and_errors</a>
<a href='#generics'>%generics</a>
<a href='#concurrency'>%concurrency</a>
<a href='#json'>%decoding_json</a>
<a href='#testing'>%testing</a>
<a href='#memory'>%memory_management</a>
<a href='#defer'>Defer</a>
<a href='#orm'>ORM</a>
<a href='#vfmt'>vfmt</a>
<a href='#writing_docs'>%writing_documentation</a>
<br>
%advanced_topics

<br>
<br>
<a href='#calling_c'>%calling_c_func_from_v</a>
<a href='#comp_if'>%compile_time_if</a>
<a href='#codegen'>%refl_via_codegen</a>
<a href='#op'>%limited_operator_overloading</a>
<a href='#asm'>%inline_assembly</a>
<a href='#cpp'>%trans_cxx_to_v</a>
<a href='#hot'>%hot_code_reloading</a>
<a href='#cross'>%cross_compile</a>
<a href='#bash'>%cross_scripts_in_v</a>
<br>
<a href='#keywords'>%appd_1_keywords</a>
<a href='#operators'>%appd_2_operators</a>

</div>


<div class='docs'>
<h2 id=introduction style='border:0; margin-top:0; padding-top:20px;'>%introduction</h2>
%intro_details

<!--
<p>
V is very strict. It helps with safety, readability, and maintainability.
-->


<h2 id=hello>Hello World</h2>

<pre><key>fn</key> main() {
	println(<str>'hello world'</str>)
}</pre>

<input class='run' type='button' value='Run'>
%fn_intro

<pre>
println(<str>'hello world'</str>)
</pre>
<input class='run' type='button' value='Run'>


<h2 id=comments>%comments</h2>

<pre>
<comment>// This is a single line comment.

/* This is a multiline comment.
   /* It can be nested. */
*/</comment></pre>


<h2 id=fns>%functions</h2>
<pre>
<key>fn </key>main() {
	println(add(77, 33))
	println(sub(100, 50))
}

<key>fn </key>add(x int, y int) int {
	return x + y
}

<key>fn </key>sub(x, y int) int {
	return x - y
}
</pre>
<input class='run' type='button' value='Run'>

<p>
Again, the type comes after the argument's name.<!-- If two or more arguments in a row have the same type,
shorter notation can be used: <code>a</code>
can be listed
-->

<p>
Just like in Go and C, functions cannot be overloaded. This simplifies the code and improves
maintainability and readability.

<p>
Functions can be used before their declaration:
<code>add</code> and <code>sub</code> are declared after <code>main</code>, but
can still be called from <code>main</code>.
<!--
unlike C, Python, F#
-->
This is true for all declarations in V and eliminates the need of header files
or thinking about the order of files and declarations.

<p>&nbsp;

<pre><key>fn </key>foo() (int, int) {
	return 2, 3
}

a, b := foo()
println(a) // 2
println(b) // 3
</pre>
<p>
Functions can return multiple values.


<p>&nbsp;

<p>
Functions, like consts, and types, are private (not exported) by default. 
To allow other modules to use them, prepend <code>pub</code>. The same applies
to consts and types.

<pre>
pub fn public_function() {
}

fn private_function() {
}
</pre>


	


 <h2 id=vars>%variables</h2>
<pre>
name := <str>'Bob'</str>
age := 20
large_number := i64(9999999999)
println(name)
println(age)
println(large_number)
</pre>
<input class='run' type='button' value='Run'>

<p>
Variables are declared and initialized with <code>:=</code>. This is the only
way to declare variables in V. This means that variables always have an initial
value.

<p>
The variable's type is inferred from the value on the right hand side.
To force a different type, use type conversion:
the expression <code>T(v)</code> converts the value <code>v</code> to the
 type <code>T</code>.

<p>
Unlike most other languages, V only allows defining variables in functions.
Global (module level) variables are not allowed. There's no global state in V.
<!--You can read why <a href='#'> here</a>.-->

<p>&nbsp;</p>

<pre>
<key>mut</key> age := 20
println(age)
age = 21
println(age)
</pre>
<input class='run' type='button' value='Run'>

<p>
To change the value of the variable use <code>=</code>. In V, variables are
immutable by default. To be able to change the value of the variable, you
have to declare it with <code>mut</code>.

<p>Try compiling the program above after removing <code>mut</code> from
the first line.


<p>
Please note the difference between <code>:=</code> and <code>=</code><br> <code>:=</code>
is used for declaring and initializing, <code>=</code> is used for assigning.

<p>&nbsp;</p>

<pre>
<key>fn </key>main() {
	age = 21
}
</pre>
<input class='run' type='button' value='Run'>
<p>
This code will not compile, because variable <code>age</code> is not declared.
All variables need to be declared in V.


<p>&nbsp;</p>

<pre>
<key>fn </key>main() {
	age := 21
}
</pre>
<input class='run' type='button' value='Run'>
<p>
In development mode this code will result in an "unused variable" warning.

In production mode (<code>v -prod foo.v</code>) it will not compile at all, like
in Go.


<p>&nbsp;</p>

<pre>
<key>fn </key>main() {
	a := 10
	if true {
		a := 20
	}
}
</pre>
<input class='run' type='button' value='Run'>
<p>
Unlike most languages, variable shadowing is not allowed. Declaring a variable with a name that is already
used in a parent scope will result in a compilation error.

<h2 id=btypes>%basic_types</h2>

<pre>
bool

string

i8    i16  int  i64      i128 (soon)
byte  u16  u32  u64      u128 (soon)

rune <comment>// represents a Unicode code point </comment>

f32 f64

byteptr
voidptr
</pre>

Please note that unlike C and Go, <code>int</code> is always a 32 bit integer.





<h2 id=strings>%strings</h2>
<pre>
name := <str>'Bob'</str>
println(<str>'Hello, </str>$name<str>!'</str>)  <comment>// `$` is used for string interpolation</comment>
println(name.len)

bobby := name + <str>'by'</str> <comment>// + is used to concatenate strings</comment>
println(bobby) <comment>// "Bobby" </comment>

println(bobby[1..3]) <comment>// "ob" </comment>
<key>mut</key> s := <str>'hello '</str>
s += <str>'world'</str> <comment>// `+=` is used to append to a string</comment>
println(s) <comment>// "hello world" </comment>
</pre>
<input class='run' type='button' value='Run'>

<p>
In V, a string is a read-only array of bytes. String data is encoded using UTF-8.
<p>
Strings are immutable. <!--This means that the substring function is very efficient:
no copying is performed, no extra allocations required. -->

<p>
Both single and double quotes can be used to denote strings. For consistency, <code>vfmt</code> converts double quotes to single quotes unless the string
contains a single quote character.

<p>
Interpolation syntax is pretty simple. It also works with fields:
<code>'age = $user.age'</code>. If you need more complex expressions, use
<code>${}</code>: <code>'can register = ${user.age > 13}'</code>.


<p>
&nbsp;

<p>
All operators in V must have values of the same type on both sides.
This code will not compile if <code>age</code> is an <code>int</code>:
<pre>println(<str>'age = '</str> + age)</pre>

We have to either convert <code>age</code> to a <code>string</code>:
 <pre>println(<str>'age = '</str> + age.str())</pre> or use string interpolation (preferred):
<pre>println(<str>'age = $age'</str>)</pre>
<!--
or simply pass a second argument to <code>println</code>:
<pre>println(<str>'age = '</str>, age) <comment>// TODO: not implemented yet</comment></pre>
-->


<p>
&nbsp;

<p>

To denote character literals, use <code>`</code>

<pre>
a := `a`
assert 'aloha!'[0] == `a`
</pre>

<p>
&nbsp;

<p>
For raw strings, prepend <code>r</code>. Raw strings are not escaped:

<pre>
s := <str>r'hello\nworld'</str>
println(s) // "hello\nworld"
</pre>


<h2 id=arrays>%arrays</h2>
<pre>
<key>mut</key> nums := [1, 2, 3]
println(nums) <comment>// "[1, 2, 3]"</comment>
println(nums[1]) <comment>// "2"</comment>

nums << 4
println(nums) <comment>// "[1, 2, 3, 4]"</comment>

nums << [5, 6, 7]
println(nums) <comment>// "[1, 2, 3, 4, 5, 6, 7]"</comment>

<key>mut</key> names := [<str>'John'</str>]
names << <str>'Peter'</str>
names << <str>'Sam'</str>
<comment>// names << 10  <-- This will not compile. `names` is an array of strings.</comment>
println(names.len) <comment>// "3"</comment>
println(<str>'Alex'</str> <key>in</key> names) <comment>// "false"</comment>

names = [] <comment>// The array is now empty</comment>

<comment>// We can also preallocate a certain amount of elements.</comment>
ids := [0].repeat(50) <comment>// This creates an array with 50 zeros</comment>
<!--
	for i := 0; i < nr_ids; i++ {
		ids[i] = i <comment>// This is more efficient than </comment>
		           <comment>// ids << i</comment>

	}
-->
</pre>

<input class='run' type='button' value='Run'>

<p>
Array type is determined by the first element: <code>[1, 2, 3]</code> is an array of ints <br>
(<code>[]int</code>). <br>
<code>['a', 'b']</code> is an array of strings (<code>[]string</code>).

<p>
All elements must have the same type. <code>[1, 'a']</code> will not compile.

<p>
<code>&lt;&lt;</code> is an operator that appends a value to the end of the array.
It can also append an entire array.

<p><code>.len</code> field returns the length of the array. Note, that it's a read-only field,
and it can't be modified by the user. All exported fields are read-only by default in V.

<p><code>val in array</code> returns true if the array contains <code>val</code>.

<p>
All arrays can be easily printed with <code>println(arr)</code> and converted to a string
with <code>s := arr.str()</code>.


<p>
&nbsp;

<p>

Arrays can be efficiently filtered and mapped with <code>.filter()</code> and
<code>.map()</code> methods:

<pre>
nums := [1, 2, 3, 4, 5, 6]
even := nums.filter(it % 2 == 0)
println(even) // [2, 4, 6]

words := ['hello', 'world']
upper := words.map(it.to_upper())
println(upper) // ['HELLO', 'WORLD']
</pre>

<code>it</code> is a special variable that refers to an element in filter/map 
methods.




<h2 id=maps>Maps</h2>
<pre>
<key>mut</key> m := map[string]int<comment> // Only maps with string keys are allowed for now </comment>
m[<str>'one'</str>] = 1
m[<str>'two'</str>] = 2
println(m[<str>'one'</str>]) <comment>// "1" </comment>
println(m[<str>'bad_key'</str>]) <comment>// "0" </comment>
println(<str>'bad_key'</str> <key>in</key> m) <comment>// Use `in` to detect whether such key exists</comment>
m.delete(<str>'two'</str>)

numbers := {
	<str>'one'</str>: 1,
	<str>'two'</str>: 2,
}
</pre>

<h2 id=if>If</h2>
<pre>
a := 10
b := 20
<key>if </key>a < b {
	println(<str>'$a < $b'</str>)
} <key>else if </key>a > b {
	println(<str>'$a > $b'</str>)
} <key>else</key> {
	println(<str>'$a == $b'</str>)
}
</pre>
<input class='run' type='button' value='Run'>

<p>
<code>if</code> statements are pretty straightforward and similar to most
other languages.

<p>
Unlike other C-like languages, there are no parentheses surrounding the
condition, and the braces are always required.
</p>

<p>
<code>if</code> can be used as an expression:
<pre>
num := 777
s := <key>if</key> num % 2 == 0 {
	<str>'even'</str>
}
<key>else</key> {
	<str>'odd'</str>
}
println(s) <comment>// "odd"</comment>
</pre>



<h2 id=in>%in_op</h2>

<code>in</code> allows to check whether an array or a map contains an element.

<pre>nums := [1, 2, 3]
println(1 <key>in</key> nums) <comment>// true</comment>

m := {'one': 1, 'two': 2}
println('one' <key>in</key> m) <comment>// true</comment>
</pre>

It's also useful for writing more clear and compact boolean expressions:

<pre><key>if</key> parser.token == .plus || parser.token == .minus ||
	parser.token == .div || parser.token == .mult {
	...
}

<key>if</key> parser.token <key>in</key> [.plus, .minus, .div, .mult] {
	...
}
</pre>

V optimizes such expressions, so both <code>if</code> statements above produce the same machine code,
no arrays are created.





<h2 id=for>%for_loop</h2>
V has only one looping construct: <code>for</code>.

<pre>
numbers := [1, 2, 3, 4, 5]
<key>for</key> num <key>in</key> numbers {
	println(num)
}
names := [<str>'Sam'</str>, <str>'Peter'</str>]
<key>for</key> i, name <key>in</key> names {
	println(<str>'$i) $name'</str>)  <comment>// Output: 0) Sam</comment>
}                             <comment>//         1) Peter</comment>
</pre>
<input class='run' type='button' value='Run'>

<p>

The <code>for value in</code> loop is used for going through elements of an array.

If an index is required, an alternative form <code>for index, value in</code> can be used.

<p>
Note, that the value is read-only. If you need to modify the array while looping,
you have to use indexing:

<pre>
<key>mut</key> numbers := [1, 2, 3, 4, 5]
<key>for</key> i, num <key>in</key> numbers {
	println(num)
	numbers[i] = 0
}
</pre>

<p>&nbsp;</p>

<pre>
mut sum := 0
mut i := 0
for i <= 100 {
	sum += i
	i++
}
println(sum) // "5050"
</pre>
<input class='run' type='button' value='Run'>

<p>
This form of the loop is similar to <code>while</code>
loops in other languages.
<p>
The loop will stop iterating once the boolean condition evaluates to false.

<p>
Again, there are no parentheses surrounding the
condition, and the braces are always required.

<p>&nbsp;</p>

<pre>
mut num := 0
for {
	num++
	<key>if </key>num >= 10 {
		break
	}
}
println(num) // "10"
</pre>
<input class='run' type='button' value='Run'>

<p>
The condition can be omitted, this results in an infinite loop.


<p>&nbsp;</p>
<pre>
for i := 0; i < 10; i++ {
	<comment>// Don't print 6</comment>
	if i == 6 {
		continue
	}
	println(i)
}
</pre>
<input class='run' type='button' value='Run'>

<p>

Finally, there's the traditional C style <code>for</code> loop. It's safer than the `while` form
because with the latter it's easy to forget to update the counter and get
stuck in an infinite loop.

<p>
Here <code>i</code> doesn't need to be declared with <code>mut</code> since it's always going to be mutable by definition.




<h2 id=match>Match</h2>
<pre>
os := 'windows'
print('V is running on ')
match os {
	'darwin' { println('macOS.') }
	'linux'  { println('Linux.') }
	else     { println(os) }
}

s := match number {
	1    { 'one' }
	2    { 'two' }
	else { 
		println('this works too')
		'many' 
	}
}
</pre>
<input class='run' type='button' value='Run'>
<p>

A match statement is a shorter way to write a sequence of <code>if - else</code> statements. When a matching branch is found, the following statement block will be run, and the final expression will be returned. The else branch will be evaluated when no other branches match.

<pre>
enum Color {
	red
	blue
	green
}

fn is_red_or_blue(c Color) bool {
	return match c {
		.red { true }
		.blue { true }
		else { false }
	}
}
</pre>
<input class='run' type='button' value='Run'>

<p>
A match statement can also be used to branch on the variants of an <code>enum</code> by using the shorthand <code>.variant_here</code> syntax.


<h2 id=structs>%structs</h2>

<pre>
<key>struct</key> Point {
	x int
	y int
}

p := Point{
	x: 10
	y: 20
}
println(p.x) <comment>// Struct fields are accessed using a dot</comment>
</pre>
<input class='run' type='button' value='Run'>

<p> &nbsp;

<p>
Structs are allocated on the stack. To allocate a struct on the heap and get
a reference to it, use the <code>&</code> prefix:

<pre>
<comment> // Alternative initialization syntax for structs with 3 fields or fewer</comment>
p := &Point{10, 10}
<comment>// References have the same syntax for accessing fields </comment>
println(p.x)
</pre>

<p>
The type of <code>p</code> is <code>&Point</code>. It's a reference to
<code>Point</code>. References are similar
to Go pointers and C++ references.

<p> &nbsp;

<p>
V doesn't have subclassing, but it supports embedded structs:



<pre>
<comment>// TODO: this will be implemented later</comment>
<key>struct</key> Button {
	Widget
	title string
}

button := new_button(<str>'Click me'</str>)
button.set_pos(x, y)

<comment>// Without embedding we'd have to do</comment>
button.widget.set_pos(x,y)
</pre>

<p> &nbsp;
<p>
Structs can have default values:
<pre>
struct Foo {
  a int
  b int = 10
}

foo := Foo{}
assert foo.a == 0
assert foo.b == 10
</pre>


<h2 id=mod>Access modifiers</h2>
<p>
Struct fields are private and immutable by default (making structs immutable as well).
Their access modifiers can be changed with
<code>pub</code> and <code>mut</code>. In total, there are 5 possible options:

<pre><key>struct</key> Foo {
	a int     <comment>// private immutable (default)</comment>
<key>mut</key>:
	b int     <comment>// private mutable</comment>
	c int     <comment>// (you can list multiple fields with the same access modifier) </comment>
<key>pub</key>:
	d int     <comment>// public immmutable (readonly)</comment>
<key>pub mut</key>:
	e int     <comment>// public, but mutable only in parent module </comment>
<key>__global</key>:
	f int 	  <comment>// public and mutable both inside and outside parent module </comment>
}                 <comment>// (not recommended to use, that's why the 'global' keyword 
                  // starts with __)</comment>
</pre>

<p> &nbsp;

<p>
For example, here's the <code>string</code> type defined in the <code>builtin</code> module:

<pre>
<key>struct</key> string {
	str byteptr
<key>pub</key>:
	len int
}
</pre>

<p>
 It's easy to see from this definition that
<code>string</code> is an immutable type.

<p>
The byte pointer with the string data is not accessible outside <code>builtin</code> at all.
<code>len</code> field is public, but not mutable:


<pre>
<key>fn</key> main() {
	str := <str>'hello'</str>
	len := str.len <comment>// OK </comment>
	str.len++      <comment>// Compilation error </comment>
}
</pre>









<h2 id=methods>%methods</h2>
<!--
<pre>
import math

struct Point {
	x int
	y int
}

<key>fn </key>(a Point) distance_to(b Point) f64 {
	return math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2)
}

p := Point{10,10}
p2 := Point{20,20}
println(p.distance_to(p2))
</pre>
-->
<pre>
struct User {
	age int
}

<key>fn </key>(u User) can_register() bool {
	return u.age > 16
}

user := User{age: 10}
println(user.can_register()) <comment>// "false" </comment>

user2 := User{age: 20}
println(user2.can_register()) <comment>// "true" </comment>
</pre>
<input class='run' type='button' value='Run'>

<p>
V doesn't have classes. But you can define methods on types.
<p>
A method is a function with a special receiver argument.
<p>

The receiver appears in its own argument list between the <code>fn</code> keyword and the method name.
<p>

<!--
In this example, the <code>distance_to</code> method has a receiver of type <code>Point</code>
named <code>a</code>.
-->

In this example, the <code>can_register</code> method has a receiver of type <code>User</code>
named <code>u</code>.  The convention is not to use receiver names like <code>self</code> or
<code>this</code>, but a short, preferably one letter long, name.


<h2 id=recvs>Pure functions by default</h2>
V functions are pure by default, meaning that their return values are only determined by
their arguments, and their evaluation has no side effects.
<p>
This is achieved by lack of global variables and all function arguments being
immutable by default, even when references are passed.

<p>
V is not a pure functional language however. It is possible to modify function arguments
by using the same keyword <code>mut</code>:


<pre><key>struct</key> User {
<key>mut</key>:
	is_registered bool
}

<key>fn </key>(u <key>mut</key> User) register() {
	u.is_registered = true
}

<key>mut</key> user := User{}
println(user.is_registered) <comment>// "false" </comment>
user.register()
println(user.is_registered) <comment>// "true" </comment>
</pre>
<input class='run' type='button' value='Run'>

<p>
In this example, the receiver (which is simply the first argument) is marked as mutable,
so <code>register()</code> can change the user object.

The same works with non-receiver arguments:

<pre>
<key>fn</key> multiply_by_2(arr <key>mut</key> []int) {
	<key>for</key> i := 0; i < arr.len; i++ {
		arr[i] *= 2
	}
}

<key>mut</key> nums := [1, 2, 3]
multiply_by_2(<key>mut</key> nums)
println(nums) <comment>// "[2, 4, 6]"
</pre>

<p>
Note, that you have to add <code>mut</code> before <code>nums</code> when calling this function. This makes
it clear that the function being called will modify the value.

<!--
<p>
Please note that functions can only modify receivers.<br><code><key>fn </key>register(u mut User)</code>
will not compile.
<p>
This is very important, so I'll say it again: V functions are partially pure, their arguments can
never be modified by the function.
<p>

-->
<p>It is preferable to return values instead of modifying arguments.
Modifying arguments should only be done in performance-critical parts of your application
to reduce allocations and copying.

<p>
For this reason V doesn't allow to modify primitive args like integers, only
complex types like arrays and maps.




<p>
Use <code>user.register()</code> or <code>user = register(user)</code>
instead of <code>register(mut user)</code>.

<p>
V makes it easy to return a modified version of an object: <br>
<pre>
<key>fn </key>register(u User) User {
	return { u | is_registered: true }
}

user = register(user)
</pre>

<h2 id=highfns> High order functions</h2>

<pre>
fn sqr(n int) int {
        return n * n
}

fn run(value int, op fn(int) int) int {
        return op(value)
}

fn main()  {
        println(run(5, sqr)) <comment>// "25"</comment>
}
</pre>


<h2 id=refs>References</h2>
<pre>
fn (foo Foo) bar_method() {
	...
}

fn bar_function(foo Foo) {
	...
}
</pre>

If a function argument is immutable like <code>foo</code> in the examples above,
V can pass it by value or by reference. The decision is made
by the compiler, and the developer doesn't need to think about it.

<p>
You no longer need to remember whether you should pass the struct by value
or by reference.

<p>
There's a way to ensure that the struct is always passed by reference by
adding <code>&</code>:

<pre>
fn (foo &Foo) bar() {
	println(foo.abc)
}
</pre>

<p>
<code>foo</code> is still immutable and can't be changed. For that,
<code>(foo mut Foo)</code> has to be used.

<p>
&nbsp;

<p>
In general, V references are similar to Go pointers and C++ references.
For example, a tree structure definition would look like this:
</p>

<pre>
struct Node&lt;T> {
	val   T
	left  &Node
	right &Node
}
</pre>




<h2 id=consts>Constants</h2>

<pre>
<key>const</key> (
	pi    = 3.14
	world = <str>'世界'</str>
)

println(pi)
println(world)
</pre>
<input class='run' type='button' value='Run'>

<p>
Constants are declared with <code>const</code>. They can only be defined
at the module level (outside of functions).

<p>
Constant values can never be changed.

<p>
V constants are more flexible than in most languages. You can assign more complex values:

<pre>
<key>struct</key> Color {
        r int
        g int
        b int
}

<key>fn </key>(c Color) str() string { return <str>'{$c.r, $c.g, $c.b}'</str> }

<key>fn </key>rgb(r, g, b int) Color { return Color{r: r, g: g, b: b} }

<key>const</key> (
        numbers = [1, 2, 3]

        red  = Color{r: 255, g: 0, b: 0}
        blue = rgb(0, 0, 255)
)

println(numbers)
println(red)
println(blue)
</pre>
<input class='run' type='button' value='Run'>

<p>
Global variables are not allowed, so this can be really useful.

<p>&nbsp;

<p>
When naming constants, snake_case must be used. 
Many people prefer all caps consts: <code>TOP_CITIES</code>. This wouldn't work
well in V, because consts are a lot more powerful than in other languages.
They can represent complex structures, and this is used quite often since there
are no globals:

<pre>
println(<str>'Top cities: $TOP_CITIES.filter(.usa)'</str>)
vs
println(<str>'Top cities: $top_cities.filter(.usa)'</str>)
</pre>




<h2 id=println>println</h2>
<p>
<code>println</code> is a simple yet powerful builtin function. It can print anything:
strings, numbers, arrays, maps, structs.

<pre>
println(1) <comment>// "1"</comment>
println('hi') <comment>// "hi"</comment>
println([1,2,3]) <comment>// "[1, 2, 3]"</comment>
println(User{name:'Bob', age:20}) <comment>// "User{name:'Bob', age:20}"</comment>
</pre>

If you want to define a custom print value for your type, simply define a
<code>.str() string</code> method.

<p>
If you don't want to print a newline, use <code>print()</code> instead.


<h2 id=modules>Modules</h2>
V is a very modular language. Creating reusable modules is encouraged and is
very simple.

To create a new module, create a directory with your module's name and
.v files with code:

<pre>
cd ~/code/modules
mkdir mymodule
vim mymodule/mymodule.v

<comment>// mymodule.v</comment>
<key>module</key> mymodule

<comment>// To export a function we have to use `pub`</comment>
<key>pub fn</key> say_hi() {
	println(<str>'hello from mymodule!'</str>)
}
</pre>

You can have as many .v files in <code>mymodule/</code> as you want.

<p>
Build it with <code>v build module ~/code/modules/mymodule</code>.

<p>
That's it, you can now use it in your code:

<pre>
<key>module</key> main

<key>import</key> mymodule

<key>fn </key>main() {
	mymodule.say_hi()
}
</pre>

<p>

Note that you have to specify the module every time you call an external function.
This may seem verbose at first, but it makes code much more readable
and easier to understand, since it's always clear which function from
which module is being called. Especially in large code bases.

<p>
Module names should be short, under 10 characters. Circular imports are not allowed.

<p>
You can create modules anywhere.

<p>
All modules are compiled statically into a single executable.

<p>
If you want to write a module that will automatically call some
setup/initialization code when imported (perhaps you want to call 
some C library functions), write a module <code>init</code> function inside the module:

<pre>
<key>fn </key>init() {
	// your setup code here ...
}
</pre>

<p>
The init function cannot be public. It will be called automatically.

<h2 id=interfaces>Interfaces</h2>
<pre>
<key>struct</key> Dog {}
<key>struct</key> Cat {}

<key>fn </key>(d Dog) speak() string {
	return <str>'woof'</str>
}

<key>fn </key>(c Cat) speak() string {
	return <str>'meow' </str>
}

<key>interface</key> Speaker {
	speak() string
}

<key>fn </key>perform(s Speaker) {
	println(s.speak())
}

dog := Dog{}
cat := Cat{}
perform(dog) <comment>// "woof" </comment>
perform(cat) <comment>// "meow" </comment>
</pre>
<input class='run' type='button' value='Run'>
<p>
A type implements an interface by implementing its methods. There is no explicit declaration of intent, no "implements" keyword.
</p>
<!--
<p>
V interfaces are very efficient. There's no dynamic dispatch.
</p>
-->

<h2 id=enums>Enums</h2>
<pre>
<key>enum</key> Color {
	red green blue
}

fn main() {
	<key>mut</key> color := Color.red
	<comment>// V knows that `color` is a `Color`. No need to use `color = Color.green` here.</comment>
	color = .green
	println(color) <comment>// "1"  TODO: print "green"? </comment>
	if color == .green {
		println("it's green")
	}
}
</pre>
<input class='run' type='button' value='Run'>

<h2 id=option>Option/Result types & error handling</h2>

<pre><key>struct</key> User {
	id int
	name string
}

<key>struct</key> Repo {
	users []User
}

<key>fn </key>new_repo() Repo {
	return Repo {
		users: [User{1, 'Andrew'}, User {2, 'Bob'}, User {10, 'Charles'}]
	}
}

<key>fn </key>(r Repo) find_user_by_id(id int) ?User {
	for user in r.users {
		<key>if </key>user.id == id {
			<comment>// V automatically wraps this into an option type </comment>
			return user
		}
	}
	return error(<str>'User </str>$id<str> not found'</str>)
}

fn main() {
	repo := new_repo()
	user := repo.find_user_by_id(10) or { <comment>// Option types must be handled by `or` blocks </comment>
		return  // <comment>`or` block must end with `return`, `break`, or `continue` </comment>
	}
	println(user.id) // <comment>"10" </comment>
	println(user.name) // <comment>"Charles"</comment>
}
</pre>
<!--
		eprintln(err)
-->
<input class='run' type='button' value='Run'>

<p>V combines <code>Option</code> and <code>Result</code> into one type, so you don't need to decide which one to use.
<p>
The amount of work required to "upgrade" a function to an optional function is minimal:
you have to add a <code>?</code> to the return type and return an error when something goes wrong.
<p>
If you don't need to return an error, you can simply <code>return none</code>.
<p>
This is the primary way of handling errors in V. They are still values, like in Go,
but the advantage is that errors can't be unhandled, and handling them is a lot less verbose.
<p>
<code>err</code> is defined inside an <code>or</code> block and is set to the string message passed
to the <code>error()</code> function. <code>err</code> is empty if <code>none</code> was returned.
<pre>
user := repo.find_user_by_id(7) or {
	println(err) <comment>// "User 7 not found"</comment>
	return
}
</pre>
<p>

You can also propagate errors:

<pre>
resp := http.get(url)?
println(resp.body)
</pre>

<code>http.get</code> returns <code>?http.Response</code>. It was called with
<code>?</code>, so the error is propagated to the calling function
(which must return an optional)  or in case of
<code>main</code> leads to a panic.

<p>Basically the code above is a shorter version of

<pre>
resp := http.get(url) or {
	panic(err)
}
println(resp.body)
</pre>

<p>
V does not have a way to force unwrap an optional (like Rust's <code>unwrap()</code>
or Swift's <code>!</code>). You have to use <code>or { panic(err) }</code> instead.





<h2 id=generics>Generics</h2>
<pre><key>struct</key> Repo&lt;T> {
	db DB
}

<key>fn </key>new_repo&lt;T>(db DB) Repo&lt;T> {
	return Repo&lt;T>{db: db}
}

<comment>// This is a generic function. V will generate it for every type it's used with.</comment>
<key>fn </key>(r Repo&lt;T>) find_by_id(id int) ?T {
	table_name := T.name <comment>// in this example getting the name of the type gives us the table name</comment>
	return r.db.query_one&lt;T>('select * from $table_name where id = ?', id)
}

db := new_db()
users_repo := new_repo&lt;User>(db)
posts_repo := new_repo&lt;Post>(db)
user := users_repo.find_by_id(1)?
post := posts_repo.find_by_id(1)?
</pre>

<h2 id=concurrency>Concurrency</h2>
The concurrency model is very similar to Go. To run <code>foo()</code> concurrently, just
call it with <code>go foo()</code>. Right now, it launches the function in a new system
thread. Soon coroutines and the scheduler will be implemented.



<h2 id=json>Decoding JSON</h2>

<pre>
<key>import</key> json

<key>struct</key> User {
	name string
	age  int

	<comment>// Use the `skip` attribute to skip certain fields</comment>
	foo Foo <str>[skip]  </str>

	<comment>// If the field name is different in JSON, it can be specified</comment>
	last_name string <str>[json:lastName]  </str>
}

data := <str>'{ "name": "Frodo", "lastName": "Baggins", "age": 25 }'</str>
user := json.decode(User, data) <key>or</key> {
	eprintln(<str>'Failed to decode json'</str>)
	return
}
println(user.name)
println(user.last_name)
println(user.age)
</pre>
<input class='run' type='button' value='Run'>

<p>
JSON is very popular nowadays, that's why JSON support is built in.
<p>
The first argument of the <code>json.decode</code> function is the type to decode to.
The second argument is the JSON string.

<p>
V generates code for JSON encoding and decoding. No runtime reflection is used. This results in much better
performance.






<h2 id=testing>Testing</h2>
<pre><comment>// hello.v</comment>
<key>fn </key>hello() string {
	return <str>'Hello world'</str>
}

<comment>// hello_test.v</comment>
<key>fn </key>test_hello() {
    <key>assert</key> hello() == <str>'Hello world'</str>
}
</pre>

All test functions have to be placed in <code>*_test.v</code> files and begin with <code>test_</code>.

<p>
To run the tests do <code>v hello_test.v</code>. To test an entire module, do
<code>v test mymodule</code>.

<p>
<code>assert</code> keyword can be used outside of tests as well.





<h2 id=memory>Memory management</h2>

(Work in progress)

There's no garbage collection or reference counting. V cleans everything up
during compilation. If your V program compiles, it's guaranteed that it's going
to be leak free.

For example:

<pre>
<key>fn</key> draw_text(s string, x, y int) {
	...
}

<key>fn</key> draw_scene() {
	...
	draw_text(<str>'hello $name1'</str>, 10, 10)
	draw_text(<str>'hello $name2'</str>, 100, 10)
	draw_text(strings.repeat(<str>'X'</str>, 10000), 10, 50)
	...
}
</pre>

The strings don't escape <code>draw_text</code>, so they are cleaned up when
the function exits.

<p>
In fact, the first two calls won't result in any allocations at all.
These two strings are small,
V will use a preallocated buffer for them.

<p>
<pre>
<key>fn</key> test() []int {
	number := 7 // stack variable
	user := User{} // struct allocated on stack
	numbers := [1, 2, 3] // array allocated on heap, will be freed as the function exits
	println(number)
	println(user)
	println(numbers)
	numbers2 := [4, 5, 6] // array that's being returned, won't be freed here
	return numbers2
}
</pre>



<h2 id=defer>Defer</h2>
A defer statement defers the execution of a block of statements until the end of scope or until surrounding function returns.

<pre>
<key>fn</key> read_log() {
	f := os.open(<str>'log.txt'</str>)
	<key>defer</key> { f.close() }
	...
	<key>if</key> !ok {
		<comment>// defer statement will be called here, the file will be closed</comment>
		<key>return</key>
	}
	...
	<comment>// defer statement will be called here, the file will be closed</comment>
}
</pre>


<h2 id=orm>ORM</h2>

(alpha)
<p>

V has a built-in ORM that supports Postgres, and will soon support MySQL and SQLite.

<p>
The benefits of V ORM:

<li>One syntax for all SQL dialects. Migrating to a different database becomes
much easier.
<li>Queries are constructed with V syntax. There's no need to learn another syntax.
<li>Safety. It's impossible to construct a SQL query with an injection.
<li>Compile time checks. No more typos that can only be caught at runtime.
<li>Readability and simplicity. You don't need to manually parse the results
and construct objects.


<pre>
struct Customer { <comment>// struct name has to be the same as the table name for now</comment>
	id int <comment>// an integer id must be the first field</comment>
	name string
	nr_orders int
	country string
}

db := pg.connect(db_name, db_user)

<comment>// select count(*) from Customer</comment>
nr_customers := db.select count from Customer
println('number of all customers: $nr_customers')

<comment>// V syntax can be used to build queries
// db.select returns an array</comment>
uk_customers := db.select from Customer where country == 'uk' && nr_orders > 0
println(uk_customers.len)
for customer in uk_customers {
	println('$customer.id - $customer.name')
}

<comment>// by adding `limit 1` we tell V that there will be only one object</comment>
customer := db.select from Customer where id == 1 limit 1
println('$customer.id - $customer.name')

<comment>// insert a new customer</comment>
new_customer := Customer{name: 'Bob', nr_orders: 10}
db.insert(new_customer)
</pre>








<h2 id=vfmt>vfmt </h2>

You don't need to worry about formatting your code or style guidelines.
vfmt takes care of that:

<pre>
v fmt file.v
</pre>

<p>
It's recommended to set up your editor, so that vfmt runs on every save.

<p>
Always run vfmt before pushing your code.


<h2 id=writing_docs>%writing_documentation</h2>

The way it works is very similar to Go. It's very simple: there's no need to
write documentation for your code, vdoc will generate it from the source code.

<p>
Documentation for each function/type/const must be placed right before the declaration:

<pre>
// clearall clears all bits in the array
fn clearall() {
}
</pre>

<p>
The comment must start with the name of the definition.

<p>
An overview of the module must be placed in the first comment right after the module's name.

<p>
To generate documentation, run <code>v doc path/to/module</code> (TODO this is
temporarily disabled).







<br>
<br>
<br>
<br>

<h1>Advanced Topics</h1>







<h2 id=calling_c>Calling C functions from V</h2>
<pre>
#flag -lsqlite3
#include "sqlite3.h"

struct C.sqlite3
struct C.sqlite3_stmt

fn C.sqlite3_column_int(stmt C.sqlite3_stmt, n int) int

fn main() {
        path := 'users.db'
        db := &C.sqlite3{!} // a temporary hack meaning `sqlite3* db = 0`
        C.sqlite3_open(path.str, &db)
        query := 'select count(*) from users'
        stmt := &C.sqlite3_stmt{!}
        C.sqlite3_prepare_v2(db, query.str, - 1, &stmt, 0)
        C.sqlite3_step(stmt)
        nr_users := C.sqlite3_column_int(stmt, 0)
        C.sqlite3_finalize(stmt)
        println(nr_users)
}
</pre>

<p>&nbsp;
<p>
Add <code>#flag</code> directives to the top of your V files
to provide C compilation flags like <code>-l</code> for
linking, <code>-I</code> for adding include files locations, <code>-D</code>
for setting compile time variables, etc.

<p>You can use different flags for different targets. Right now, <code>linux</code> ,
<code>darwin</code> , and <code>windows</code> are supported.

<p>
For now you have to use one flag per line:

<pre>
#flag linux -lsdl2
#flag linux -Ivig
#flag linux -DCIMGUI_DEFINE_ENUMS_AND_STRUCTS=1
#flag linux -DIMGUI_DISABLE_OBSOLETE_FUNCTIONS=1
#flag linux -DIMGUI_IMPL_API=
</pre>


<p>&nbsp;
<p>
C strings can be converted to V strings with
<code>string(cstring)</code> or
<code>string(cstring, len)</code>.

<p>
V uses <code>voidptr</code> for C's <code>void*</code> and
 <code>byteptr</code> for C's <code>byte*</code> or <code>char*</code>.

<p>
To cast <code>voidptr</code> to V references use <code>user := &User(user_void_ptr)</code>.

<p>
<code>voidptr</code> can also be dereferenced to V structs by casting: <code>user := User(user_void_ptr)</code>.

<p>
Check out socket.v for an example of calling C code from V:

<a target=_blank href='https://github.com/vlang/v/blob/master/vlib/net/socket.v'>https://github.com/vlang/v/blob/master/vlib/net/socket.v</a>

<p>
To debug issues with the C code, <code>v -show_c_cmd .</code> is useful. It prints the 
C command that is used to build the program.




<h2 id=comp_if>Compile time if</h2>
<pre><key>$if</key> windows {
	println('Windows')
}
<key>$if</key> linux {
	println('Linux')
}
<key>$if</key> mac {
	println('macOS')
}

<key>$if</key> debug {
	println('debugging')
}
</pre>

Compile time <code>if</code> starts with a <code>$</code>. Right now it can only be used to detect
an OS or a <code>-debug</code> compilation option.

<h2 id=codegen>Reflection via codegen</h2>
Having built-in JSON support is nice, but V also allows you to create efficient
serializers for anything:

<pre>
<comment>// TODO: not implemented yet</comment>
<key>fn</key> decode&lt;T>(data string) T {
        mut result := T{}
        for field in T.fields {
                if field.typ == <str>'string'</str> {
                        result.$field = get_string(data, field.name)
                } else if field.typ == <str>'int'</str> {
                        result.$field = get_int(data, field.name)
                }
        }
        return result
}

<comment>// generates to:</comment>
fn decode_User(data string) User {
        mut result := User{}
        result.name = get_string(data, 'name')
        result.age = get_int(data, 'age')
        return result
}
</pre>



<h2 id=op> Limited operator overloading</h2>

<pre><key>struct</key> Vec {
	x int
	y int
}

<key>fn</key> (a Vec) str() string {
	<key>return</key> <str>'{$a.x, $a.y}'</str>
}

<key>fn</key> (a Vec) + (b Vec) Vec {
	<key>return</key> Vec {
		a.x + b.x,
		a.y + b.y
	}
}

<key>fn</key> (a Vec) - (b Vec) Vec {
	<key>return</key> Vec {
		a.x - b.x,
		a.y - b.y
	}
}

<key>fn</key> main() {
	a := Vec{2, 3}
	b := Vec{4, 5}
	println(a + b) <comment>// "{6, 8}" </comment>
	println(a - b) <comment>// "{-2, -2}" </comment>
}
</pre>
<input class='run' type='button' value='Run'>

<p>
Operator overloading goes against V's philosophy of simplicity and predictability. But since
scientific and graphical applications are among V's domains, operator overloading is very important to have
in order to improve readability:

<p>
<code>a.add(b).add(c.mul(d))</code> is a lot less readable than <code>a + b + c * d</code>.

<p>
To improve safety and maintainability, operator overloading has several limitations:

<p>
- It's only possible to overload <code>+, -, *, /</code>  operators. <br>
- Calling other functions inside operator functions is not allowed.  <br>
- Operator functions can't modify their arguments.  <br>
- Both arguments must have the same type (just like with all operators in V).





<h2 id=asm> Inline assembly</h2>

TODO: not implemented yet

<pre>
fn main() {
	a := 10
	asm x64 {
		mov eax, [a]
		add eax, 10
		mov [a], eax
	}
}
</pre>










<h2 id=cpp>Translating C/C++ to V</h2>

TODO: translating C to V will be available in V 0.3. C++ to V will be available later this year.
<p>

V can translate your C/C++ code to human readable V code.

Let's create a simple program <code>test.cpp</code> first:

<pre>#include &lt;vector>
#include &lt;string>
#include &lt;iostream>

int main() {
        std::vector&lt;std::string> s;
        s.push_back("V is ");
        s.push_back("awesome");
        std::cout << s.size() << std::endl;
        return 0;
}
</pre>

Run <code>v translate test.cpp</code> and V will generate <code>test.v</code>:

<pre><key>fn </key>main {
        mut s := []
	s << 'V is '
	s << 'awesome'
	println(s.len)
}
</pre>

<p>
An online C/C++ to V translator is coming soon.

<p>
When should you translate C code and when should you simply call C code from V?

<p>
If you have well-written, well-tested C code, then of course you can always simply call this C code from V.

<p>
Translating it to V gives you several advantages:

<p>
- If you plan to develop that code base, you now have everything in one language, which is much safer and easier to develop in than C.

<p>
- Cross-compilation becomes a lot easier. You don't have to worry about it at all.

<p>
- No more build flags and include files either.


<h2 id=hot>Hot code reloading</h2>
<pre>
module main

import time
import os

[live]
fn print_message() {
	println('Hello! Modify this message while the program is running.')
}

fn main() {
	for {
		print_message()
		time.sleep_ms(500)
	}
}

</pre>

Build this example with <code>v -live message.v</code>.
<p>
Functions that you want to be reloaded must have <code>[live]</code> attribute
before their definition.

<p>
Right now it's not possible to modify types while the program is running.

<p>
More examples, including a graphical application:

<a target=_blank href='https://github.com/vlang/v/tree/master/examples/hot_code_reloading'
>github.com/vlang/v/tree/master/examples/hot_code_reloading</a>.

<h2 id=cross>Cross compilation</h2>
To cross compile your project simply run

<pre>
v -os windows .
</pre>

or

<pre>
v -os linux .
</pre>

(Cross compiling for macOS is temporarily not possible.)

<p>
If you don't have any C dependencies, that's all you need to do. This works even
when compiling GUI apps using the <code>ui</code> module or graphical apps using
<code>gg</code>.

<p>
You will need to install Clang, LLD linker, and download a zip file with
libraries and include files for Windows and Linux. V will provide you with a link.


<h2 id=bash>Cross-platform shell scripts in V</h2>

<p>
V can be used as an alternative to Bash to write deployment scripts, build scripts,
etc.

<p>
The advantage of using V for this is the simplicity and predictability of the language, and
cross-platform support. "V scripts" run on Unix-like systems as well as on Windows.

<p>
Use .vsh file extension. It will make all functions in the <code>os</code>
module global (so that you can use <code>ls()</code> instead of <code>os.ls()</code>, for example).

<pre>
rm(<str>'build/*'</str>)
<comment>// Same as: </comment>
<key>for</key> file <key>in</key> ls(<str>'build/'</str>) {
	rm(file)
}

mv(<str>'*.v'</str>, <str>'build/'</str>)
<comment>// Same as: </comment>
<key>for</key> file <key>in</key> ls(<str>'.'</str>) {
	<key>if</key> file.ends_with(<str>'.v'</str>) {
		mv(file, <str>'build/'</str>)
	}
}
</pre>

Now you can either compile this like a normal V program and get an executable you can deploy and run
anywhere:

<code>v deploy.v && ./deploy</code>


<p>
Or just run it more like a traditional bash script:

<code>v run deploy.v</code>




<h2 id=keywords>Appendix I: Keywords</h2>

V has 23 keywords:

<pre>
break
const
continue
defer
else
enum
fn
for
go
goto
if
import
in
interface
match
module
mut
none
or
pub
return
struct
type
</pre>


<h2 id=operators>Appendix II: Operators</h2>
<pre>
+    sum                    integers, floats, strings
-    difference             integers, floats
*    product                integers, floats
/    quotient               integers, floats
%    remainder              integers

&    bitwise AND            integers
|    bitwise OR             integers
^    bitwise XOR            integers

<<   left shift             integer << unsigned integer
>>   right shift            integer >> unsigned integer


Precedence    Operator
    5             *  /  %  <<  >>  &
    4             +  -  |  ^
    3             ==  !=  <  <=  >  >=
    2             &&
    1             ||


Assignment Operators
+=   -=   *=   /=   %=
&=   |=   ^=
>>=  <<=
</pre>


</div>
</div>

	</body>

</html>
@t footer
